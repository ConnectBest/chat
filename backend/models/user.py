"""
User Model

This module defines the User model for MongoDB.
Handles user data including authentication, profile, and preferences.

LEARNING NOTE:
- MongoDB stores data as documents (similar to JSON)
- We use Python dictionaries to represent documents
- '_id' is auto-generated by MongoDB as unique identifier
"""

from datetime import datetime
from bson.objectid import ObjectId
import bcrypt
from typing import Optional, Dict, Any


class User:
    """
    User Model representing users in the chat application.
    
    Collections in MongoDB: 'users'
    
    Fields:
        - _id: MongoDB ObjectId (unique identifier)
        - email: User's email (unique, required)
        - password_hash: Encrypted password (never stored as plain text!)
        - name: User's full name (required)
        - phone: Phone number (optional)
        - role: 'admin' or 'user' (default: 'user')
        - status: online status (default: 'offline')
        - status_message: Custom status message
        - avatar_url: Profile picture URL
        - email_verified: Boolean flag
        - created_at: Registration timestamp
        - updated_at: Last update timestamp
        - last_login: Last login timestamp
    """
    
    # MongoDB collection name
    COLLECTION = 'users'
    
    # Valid user roles
    ROLES = ['admin', 'user']
    
    # Valid status values
    STATUSES = ['online', 'away', 'busy', 'inmeeting', 'offline']
    
    def __init__(self, db):
        """
        Initialize User model with database connection
        
        Args:
            db: MongoDB database instance
        """
        self.collection = db[self.COLLECTION]
    
    def create(self, user_data: Dict[str, Any]) -> str:
        """
        Create a new user in the database.
        
        LEARNING NOTE:
        - Passwords are NEVER stored as plain text (unless OAuth user)
        - bcrypt is used to hash passwords (one-way encryption)
        - Even if database is compromised, passwords are safe
        
        Args:
            user_data: Dictionary containing user information
                Required: email, username
                Optional: password, full_name, avatar, google_id, oauth_provider, role
        
        Returns:
            str: Created user's ID
        
        Raises:
            ValueError: If email already exists or validation fails
        """
        
        # Check if user with this email already exists
        email = user_data.get('email')
        if self.find_by_email(email):
            raise ValueError('User with this email already exists')
        
        # Check if username exists
        username = user_data.get('username')
        if self.find_by_username(username):
            raise ValueError('User with this username already exists')
        
        # Validate role
        role = user_data.get('role', 'user')
        if role not in self.ROLES:
            raise ValueError(f'Invalid role. Must be one of: {self.ROLES}')
        
        # Hash password if provided (OAuth users may not have password)
        password_hash = None
        if 'password' in user_data and user_data['password']:
            password_hash = bcrypt.hashpw(
                user_data['password'].encode('utf-8'),
                bcrypt.gensalt()
            ).decode('utf-8')
        
        # Create user document
        user_doc = {
            'email': email.lower().strip(),
            'username': username.lower().strip(),
            'password_hash': password_hash,
            'full_name': user_data.get('full_name', ''),
            'avatar': user_data.get('avatar'),
            'role': role,
            'status': user_data.get('status', 'online'),
            # Email verification fields
            'email_verified': user_data.get('email_verified', False),
            'verification_token': user_data.get('verification_token'),
            'verification_expires': user_data.get('verification_expires'),
            # 2FA fields
            'two_factor_enabled': False,
            'two_factor_secret': None,
            'backup_codes': [],
            # OAuth fields
            'google_id': user_data.get('google_id'),
            'oauth_provider': user_data.get('oauth_provider'),
            'created_at': datetime.utcnow(),
            'updated_at': datetime.utcnow(),
            'last_login': None,
        }
        
        # Insert into MongoDB
        result = self.collection.insert_one(user_doc)
        
        # Return user ID as string
        return str(result.inserted_id)
    
    def find_by_id(self, user_id: str) -> Optional[Dict[str, Any]]:
        """
        Find a user by their ID.
        
        Args:
            user_id: MongoDB ObjectId as string
        
        Returns:
            dict: User document or None if not found
        """
        try:
            user = self.collection.find_one({'_id': ObjectId(user_id)})
            return self._format_user(user) if user else None
        except Exception:
            return None
    
    def find_by_email(self, email: str) -> Optional[Dict[str, Any]]:
        """
        Find a user by their email address.
        
        Args:
            email: User's email address
        
        Returns:
            dict: User document or None if not found
        """
        user = self.collection.find_one({'email': email.lower().strip()})
        return user  # Return full document (including password_hash) for authentication
    
    def find_by_username(self, username: str) -> Optional[Dict[str, Any]]:
        """
        Find a user by their username.
        
        Args:
            username: User's username
        
        Returns:
            dict: User document or None if not found
        """
        user = self.collection.find_one({'username': username.lower().strip()})
        return user
    
    def find_all(self) -> list:
        """
        Get all users from the database.
        
        Returns:
            list: List of all user documents (excluding password hashes)
        """
        try:
            users = list(self.collection.find({}, {'password_hash': 0}))
            return users
        except Exception as e:
            print(f"Error fetching users: {e}")
            return []
    
    def verify_password(self, user: Dict[str, Any], password: str) -> bool:
        """
        Verify a password against stored hash.
        
        LEARNING NOTE:
        - bcrypt.checkpw compares plain text password with hash
        - It's cryptographically secure - can't reverse the hash
        - Takes same time regardless of password length (prevents timing attacks)
        
        Args:
            user: User document with password_hash
            password: Plain text password to verify
        
        Returns:
            bool: True if password matches, False otherwise
        """
        if not user or 'password_hash' not in user:
            return False
        
        return bcrypt.checkpw(
            password.encode('utf-8'),
            user['password_hash'].encode('utf-8')
        )
    
    def update(self, user_id: str, updates: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Update user information.
        
        Args:
            user_id: MongoDB ObjectId as string
            updates: Dictionary of fields to update
        
        Returns:
            dict: Updated user document or None if not found
        """
        # Add updated_at timestamp
        updates['updated_at'] = datetime.utcnow()
        
        # Remove fields that shouldn't be directly updated
        protected_fields = ['_id', 'password_hash', 'email', 'created_at']
        for field in protected_fields:
            updates.pop(field, None)
        
        try:
            result = self.collection.find_one_and_update(
                {'_id': ObjectId(user_id)},
                {'$set': updates},
                return_document=True  # Return updated document
            )
            return self._format_user(result) if result else None
        except Exception:
            return None
    
    def update_status(self, user_id: str, status: str, 
                     status_message: Optional[str] = None) -> bool:
        """
        Update user's online status.
        
        Args:
            user_id: MongoDB ObjectId as string
            status: New status (online, away, busy, inmeeting, offline)
            status_message: Optional custom status message
        
        Returns:
            bool: True if successful, False otherwise
        """
        if status not in self.STATUSES:
            raise ValueError(f'Invalid status. Must be one of: {self.STATUSES}')
        
        updates = {
            'status': status,
            'updated_at': datetime.utcnow()
        }
        
        if status_message is not None:
            updates['status_message'] = status_message
        
        try:
            result = self.collection.update_one(
                {'_id': ObjectId(user_id)},
                {'$set': updates}
            )
            return result.modified_count > 0
        except Exception:
            return False
    
    def update_last_login(self, user_id: str) -> bool:
        """
        Update user's last login timestamp.
        
        Args:
            user_id: MongoDB ObjectId as string
        
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            result = self.collection.update_one(
                {'_id': ObjectId(user_id)},
                {'$set': {'last_login': datetime.utcnow()}}
            )
            return result.modified_count > 0
        except Exception:
            return False
    
    def verify_email(self, verification_token: str) -> Optional[Dict[str, Any]]:
        """
        Verify user's email using verification token.
        
        Args:
            verification_token: Unique verification token
        
        Returns:
            dict: Updated user document or None if token invalid/expired
        """
        try:
            # Find user with matching token and check expiration
            user = self.collection.find_one({
                'verification_token': verification_token,
                'verification_expires': {'$gt': datetime.utcnow()}
            })
            
            if not user:
                return None
            
            # Update user: mark as verified and remove token
            result = self.collection.find_one_and_update(
                {'_id': user['_id']},
                {
                    '$set': {
                        'email_verified': True,
                        'updated_at': datetime.utcnow()
                    },
                    '$unset': {
                        'verification_token': '',
                        'verification_expires': ''
                    }
                },
                return_document=True
            )
            
            return self._format_user(result) if result else None
            
        except Exception as e:
            print(f"Error verifying email: {e}")
            return None
    
    def search_users(self, query: str, limit: int = 20) -> list:
        """
        Search for users by name or email.
        
        Args:
            query: Search query string
            limit: Maximum number of results
        
        Returns:
            list: List of matching user documents
        """
        # Case-insensitive regex search
        regex = {'$regex': query, '$options': 'i'}
        
        users = self.collection.find({
            '$or': [
                {'name': regex},
                {'email': regex}
            ],
            'deleted_at': None  # Exclude deleted users
        }).limit(limit)
        
        return [self._format_user(user) for user in users]
    
    def _format_user(self, user: Optional[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        """
        Format user document for API response.
        Removes sensitive fields like password_hash.
        
        Args:
            user: Raw user document from MongoDB
        
        Returns:
            dict: Formatted user document safe for API response
        """
        if not user:
            return None
        
        # Convert ObjectId to string for JSON serialization
        user['id'] = str(user['_id'])
        
        # Remove MongoDB _id field (we use 'id' instead)
        user.pop('_id', None)
        
        # Remove sensitive information
        user.pop('password_hash', None)
        
        # Convert datetime objects to ISO format strings
        for field in ['created_at', 'updated_at', 'last_login', 'deleted_at', 'verification_expires']:
            if field in user and user[field]:
                user[field] = user[field].isoformat()
        
        return user
    
    def _to_object_id(self, id_string: str) -> ObjectId:
        """
        Convert string ID to MongoDB ObjectId.
        
        Args:
            id_string: String representation of ObjectId
        
        Returns:
            ObjectId: MongoDB ObjectId instance
        """
        try:
            return ObjectId(id_string)
        except Exception:
            raise ValueError(f"Invalid ObjectId: {id_string}")
    
    def list_all(self, skip: int = 0, limit: int = 50) -> list:
        """
        List all users with pagination.
        
        Args:
            skip: Number of documents to skip
            limit: Maximum number of documents to return
        
        Returns:
            list: List of user documents
        """
        users = self.collection.find({
            'deleted_at': None
        }).skip(skip).limit(limit).sort('created_at', -1)
        
        return [self._format_user(user) for user in users]
    
    def count_total(self) -> int:
        """
        Get total number of users.
        
        Returns:
            int: Total user count
        """
        return self.collection.count_documents({'deleted_at': None})
