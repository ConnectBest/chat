name: Build & Deploy Multi-Container to ECS

on:
  push:
    branches: [main]
  workflow_dispatch: {}

env:
  # Shared org vars
  AWS_REGION:       ${{ vars.AWS_REGION }}        # e.g., us-west-2
  AWS_ACCOUNT_ID:   ${{ vars.AWS_ACCOUNT_ID }}
  ECR_PUBLIC_ALIAS: ${{ vars.ECR_PUBLIC_ALIAS }}  # e.g., connectbest

  # Tags
  IMAGE_TAG_SHA: ${{ github.sha }}
  IMAGE_TAG_REF: ${{ github.ref_name }}

  # ECS
  ECS_CLUSTER: chat-app-cluster
  ECS_SERVICE: chat-app-service

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
      actions: write

    outputs:
      frontend-image-uri: ${{ steps.image-uris.outputs.frontend-uri }}
      backend-image-uri: ${{ steps.image-uris.outputs.backend-uri }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      # Ensure private repos exist
      - name: Ensure Private ECR repos exist
        run: |
          # Frontend repo
          aws ecr describe-repositories \
            --region "${AWS_REGION}" \
            --repository-names "chat-frontend" >/dev/null 2>&1 || \
          aws ecr create-repository \
            --region "${AWS_REGION}" \
            --repository-name "chat-frontend" \
            --image-scanning-configuration scanOnPush=true \
            --encryption-configuration encryptionType=AES256

          # Backend repo
          aws ecr describe-repositories \
            --region "${AWS_REGION}" \
            --repository-names "chat-backend" >/dev/null 2>&1 || \
          aws ecr create-repository \
            --region "${AWS_REGION}" \
            --repository-name "chat-backend" \
            --image-scanning-configuration scanOnPush=true \
            --encryption-configuration encryptionType=AES256

      # Ensure public repos exist
      - name: Ensure Public ECR repos exist (us-east-1)
        run: |
          # Frontend repo
          aws ecr-public describe-repositories --region us-east-1 \
            --repository-names "chat-frontend" >/dev/null 2>&1 || \
          aws ecr-public create-repository --region us-east-1 \
            --repository-name "chat-frontend" >/dev/null

          # Backend repo
          aws ecr-public describe-repositories --region us-east-1 \
            --repository-names "chat-backend" >/dev/null 2>&1 || \
          aws ecr-public create-repository --region us-east-1 \
            --repository-name "chat-backend" >/dev/null

      # Logins
      - name: Login to Private ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Login to Public ECR
        env:
          AWS_REGION: us-east-1
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Compute image URIs
        id: uris
        run: |
          echo "PUBLIC_FRONTEND_URI=public.ecr.aws/${ECR_PUBLIC_ALIAS}/chat-frontend" >> $GITHUB_OUTPUT
          echo "PUBLIC_BACKEND_URI=public.ecr.aws/${ECR_PUBLIC_ALIAS}/chat-backend" >> $GITHUB_OUTPUT
          echo "PRIVATE_FRONTEND_URI=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/chat-frontend" >> $GITHUB_OUTPUT
          echo "PRIVATE_BACKEND_URI=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/chat-backend" >> $GITHUB_OUTPUT

      # Build and push frontend
      - name: Build & Push Frontend to both registries
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile.frontend
          push: true
          build-args: |
            CACHEBUST=${{ github.run_number }}
            NEXT_PUBLIC_API_URL=/api
            NEXT_PUBLIC_WS_URL=
            NEXT_PUBLIC_WEBSOCKET_URL=${{ secrets.WEBSOCKET_URL }}
          tags: |
            ${{ steps.uris.outputs.PUBLIC_FRONTEND_URI }}:latest
            ${{ steps.uris.outputs.PUBLIC_FRONTEND_URI }}:${{ env.IMAGE_TAG_SHA }}
            ${{ steps.uris.outputs.PUBLIC_FRONTEND_URI }}:${{ env.IMAGE_TAG_REF }}
            ${{ steps.uris.outputs.PRIVATE_FRONTEND_URI }}:latest
            ${{ steps.uris.outputs.PRIVATE_FRONTEND_URI }}:${{ env.IMAGE_TAG_SHA }}
            ${{ steps.uris.outputs.PRIVATE_FRONTEND_URI }}:${{ env.IMAGE_TAG_REF }}
          cache-from: type=gha,scope=frontend
          cache-to: type=gha,mode=max,scope=frontend
          platforms: linux/amd64

      # Build and push backend
      - name: Build & Push Backend to both registries
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile.backend
          push: true
          build-args: |
            CACHEBUST=${{ github.run_number }}
          tags: |
            ${{ steps.uris.outputs.PUBLIC_BACKEND_URI }}:latest
            ${{ steps.uris.outputs.PUBLIC_BACKEND_URI }}:${{ env.IMAGE_TAG_SHA }}
            ${{ steps.uris.outputs.PUBLIC_BACKEND_URI }}:${{ env.IMAGE_TAG_REF }}
            ${{ steps.uris.outputs.PRIVATE_BACKEND_URI }}:latest
            ${{ steps.uris.outputs.PRIVATE_BACKEND_URI }}:${{ env.IMAGE_TAG_SHA }}
            ${{ steps.uris.outputs.PRIVATE_BACKEND_URI }}:${{ env.IMAGE_TAG_REF }}
          cache-from: type=gha,scope=backend
          cache-to: type=gha,mode=max,scope=backend
          platforms: linux/amd64

      - name: Set image URI outputs
        id: image-uris
        run: |
          echo "frontend-uri=${{ steps.uris.outputs.PRIVATE_FRONTEND_URI }}:${{ env.IMAGE_TAG_SHA }}" >> $GITHUB_OUTPUT
          echo "backend-uri=${{ steps.uris.outputs.PRIVATE_BACKEND_URI }}:${{ env.IMAGE_TAG_SHA }}" >> $GITHUB_OUTPUT

      - name: Output pushed tags
        run: |
          echo "Frontend Public:  ${{ steps.uris.outputs.PUBLIC_FRONTEND_URI }}:{latest,${{ env.IMAGE_TAG_SHA }},${{ env.IMAGE_TAG_REF }}}"
          echo "Frontend Private: ${{ steps.uris.outputs.PRIVATE_FRONTEND_URI }}:{latest,${{ env.IMAGE_TAG_SHA }},${{ env.IMAGE_TAG_REF }}}"
          echo "Backend Public:   ${{ steps.uris.outputs.PUBLIC_BACKEND_URI }}:{latest,${{ env.IMAGE_TAG_SHA }},${{ env.IMAGE_TAG_REF }}}"
          echo "Backend Private:  ${{ steps.uris.outputs.PRIVATE_BACKEND_URI }}:{latest,${{ env.IMAGE_TAG_SHA }},${{ env.IMAGE_TAG_REF }}}"

  deploy-ecs:
    needs: build-and-push
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy updated infrastructure
        env:
          MONGODB_URI: ${{ secrets.MONGODB_URI }}
          JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
        run: |
          cd infrastructure
          npm config set registry https://registry.npmjs.org/
          rm -f package-lock.json
          rm -rf node_modules
          rm -rf lib/*.js lib/*.d.ts
          npm install
          npm run build
          npx cdk deploy --require-approval never

      - name: Wait for deployment to complete
        run: |
          echo "Waiting for ECS service to stabilize..."

          # Set timeout for wait command (10 minutes)
          timeout 600 aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} || {
            echo "Wait timed out or failed, checking service status manually..."

            # Check if deployment actually succeeded
            DEPLOYMENT_STATUS=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }} \
              --services ${{ env.ECS_SERVICE }} \
              --query 'services[0].deployments[0].{status:status,rolloutState:rolloutState}' \
              --output json)

            echo "Current deployment status: $DEPLOYMENT_STATUS"

            # Check if we have at least one running task
            RUNNING_COUNT=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }} \
              --services ${{ env.ECS_SERVICE }} \
              --query 'services[0].runningCount' \
              --output text)

            if [ "$RUNNING_COUNT" -gt 0 ]; then
              echo "✅ Service has $RUNNING_COUNT running tasks, considering deployment successful"
            else
              echo "❌ No running tasks found, deployment may have failed"
              exit 1
            fi
          }

          echo "ECS service wait completed or timed out successfully"

      - name: Get deployment status
        run: |
          echo "ECS deployment complete!"

          # Get load balancer DNS name
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names chat-app-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)

          echo "Application URL: http://$ALB_DNS"
          echo "Health Check: http://$ALB_DNS/api/health"

          # Get service status
          aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].{Status:status,TaskDefinition:taskDefinition,RunningCount:runningCount,DesiredCount:desiredCount}'