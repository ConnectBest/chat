name: Build & Deploy to ECS

on:
  push:
    branches: [main]
  workflow_dispatch: {}

env:
  # Shared org vars
  AWS_REGION:       ${{ vars.AWS_REGION }}        # e.g., us-west-2
  AWS_ACCOUNT_ID:   ${{ vars.AWS_ACCOUNT_ID }}
  ECR_PUBLIC_ALIAS: ${{ vars.ECR_PUBLIC_ALIAS }}  # e.g., connectbest

  # Repo var
  ECR_PUBLIC_REPO:  ${{ vars.ECR_PUBLIC_REPO }}   # e.g., chat

  # Tags
  IMAGE_TAG_SHA: ${{ github.sha }}
  IMAGE_TAG_REF: ${{ github.ref_name }}

  # ECS
  ECS_CLUSTER: chat-app-cluster
  ECS_SERVICE: chat-app-service

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
      actions: write

    outputs:
      image-uri: ${{ steps.image-uri.outputs.uri }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      # Ensure private repo exists
      - name: Ensure Private ECR repo exists
        run: |
          aws ecr describe-repositories \
            --region "${AWS_REGION}" \
            --repository-names "${ECR_PUBLIC_REPO}" >/dev/null 2>&1 || \
          aws ecr create-repository \
            --region "${AWS_REGION}" \
            --repository-name "${ECR_PUBLIC_REPO}" \
            --image-scanning-configuration scanOnPush=true \
            --encryption-configuration encryptionType=AES256

      # Ensure public repo exists
      - name: Ensure Public ECR repo exists (us-east-1)
        run: |
          aws ecr-public describe-repositories --region us-east-1 \
            --repository-names "${ECR_PUBLIC_REPO}" >/dev/null 2>&1 || \
          aws ecr-public create-repository --region us-east-1 \
            --repository-name "${ECR_PUBLIC_REPO}" >/dev/null

      # Logins
      - name: Login to Private ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Login to Public ECR
        env:
          AWS_REGION: us-east-1
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Compute image URIs
        id: uris
        run: |
          echo "PUBLIC_URI=public.ecr.aws/${ECR_PUBLIC_ALIAS}/${ECR_PUBLIC_REPO}" >> $GITHUB_OUTPUT
          echo "PRIVATE_URI=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_PUBLIC_REPO}" >> $GITHUB_OUTPUT

      - name: Build & Push to both registries
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          build-args: |
            CACHEBUST=${{ github.run_number }}
            NEXT_PUBLIC_API_URL=http://localhost:5001/api
            NEXT_PUBLIC_WS_URL=http://localhost:5001
            NEXT_PUBLIC_WEBSOCKET_URL=${{ secrets.WEBSOCKET_URL }}
          tags: |
            ${{ steps.uris.outputs.PUBLIC_URI }}:latest
            ${{ steps.uris.outputs.PUBLIC_URI }}:${{ env.IMAGE_TAG_SHA }}
            ${{ steps.uris.outputs.PUBLIC_URI }}:${{ env.IMAGE_TAG_REF }}
            ${{ steps.uris.outputs.PRIVATE_URI }}:latest
            ${{ steps.uris.outputs.PRIVATE_URI }}:${{ env.IMAGE_TAG_SHA }}
            ${{ steps.uris.outputs.PRIVATE_URI }}:${{ env.IMAGE_TAG_REF }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: Set image URI output
        id: image-uri
        run: |
          echo "uri=${{ steps.uris.outputs.PRIVATE_URI }}:${{ env.IMAGE_TAG_SHA }}" >> $GITHUB_OUTPUT

      - name: Output pushed tags
        run: |
          echo "Public:  ${{ steps.uris.outputs.PUBLIC_URI }}:{latest,${{ env.IMAGE_TAG_SHA }},${{ env.IMAGE_TAG_REF }}}"
          echo "Private: ${{ steps.uris.outputs.PRIVATE_URI }}:{latest,${{ env.IMAGE_TAG_SHA }},${{ env.IMAGE_TAG_REF }}}"

  deploy-ecs:
    needs: build-and-push
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update ECS Task Definition
        id: task-def
        run: |
          # Get current task definition
          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].taskDefinition' \
            --output text)

          if [ "$TASK_DEF_ARN" = "None" ] || [ -z "$TASK_DEF_ARN" ]; then
            echo "ECS service not found. Please run infrastructure deployment first."
            exit 1
          fi

          # Get task definition and clean it for registration
          aws ecs describe-task-definition \
            --task-definition $TASK_DEF_ARN \
            --query 'taskDefinition' > task-definition.json

          # Update image URI in task definition
          NEW_IMAGE_URI="${{ needs.build-and-push.outputs.image-uri }}"
          echo "Updating to new image: $NEW_IMAGE_URI"

          # Use jq to update the image URI and clean the task definition
          jq --arg IMAGE_URI "$NEW_IMAGE_URI" \
             '.containerDefinitions[0].image = $IMAGE_URI |
              del(.taskDefinitionArn, .revision, .status, .requiresAttributes?, .placementConstraints?, .compatibilities?, .registeredAt?, .registeredBy?, .tags?)' \
             task-definition.json > updated-task-definition.json

          echo "Updated task definition:"
          cat updated-task-definition.json

          # Register new task definition
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://updated-task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "New task definition registered: $NEW_TASK_DEF_ARN"
          echo "task-def-arn=$NEW_TASK_DEF_ARN" >> $GITHUB_OUTPUT

      - name: Update ECS Service
        run: |
          echo "Updating ECS service with new task definition..."
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition ${{ steps.task-def.outputs.task-def-arn }} \
            --force-new-deployment

      - name: Wait for deployment to complete
        run: |
          echo "Waiting for ECS service to stabilize..."

          # Set timeout for wait command (10 minutes)
          timeout 600 aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} || {
            echo "Wait timed out or failed, checking service status manually..."

            # Check if deployment actually succeeded
            DEPLOYMENT_STATUS=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }} \
              --services ${{ env.ECS_SERVICE }} \
              --query 'services[0].deployments[0].{status:status,rolloutState:rolloutState}' \
              --output json)

            echo "Current deployment status: $DEPLOYMENT_STATUS"

            # Check if we have at least one running task
            RUNNING_COUNT=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }} \
              --services ${{ env.ECS_SERVICE }} \
              --query 'services[0].runningCount' \
              --output text)

            if [ "$RUNNING_COUNT" -gt 0 ]; then
              echo "✅ Service has $RUNNING_COUNT running tasks, considering deployment successful"
            else
              echo "❌ No running tasks found, deployment may have failed"
              exit 1
            fi
          }

          echo "ECS service wait completed or timed out successfully"

      - name: Get deployment status
        run: |
          echo "ECS deployment complete!"

          # Get load balancer DNS name
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names chat-app-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)

          echo "Application URL: http://$ALB_DNS"
          echo "Health Check: http://$ALB_DNS/api/health"

          # Get service status
          aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].{Status:status,TaskDefinition:taskDefinition,RunningCount:runningCount,DesiredCount:desiredCount}'